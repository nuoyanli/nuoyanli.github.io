<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>test</title>
    <url>/archives/f82e.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>2020NYIST个人积分赛第九场F题cf1144F</title>
    <url>/archives/344.html</url>
    <content><![CDATA[<p>个人博客链接：<a href="https://blog.nuoyanli.com/2020/04/22/cf1144f/" target="_blank" rel="noopener external nofollow noreferrer">https://blog.nuoyanli.com/2020/04/22/cf1144f/</a></p>
<h2 id="2020NYIST个人积分赛第九场F题"><a href="#2020NYIST个人积分赛第九场F题" class="headerlink" title="2020NYIST个人积分赛第九场F题"></a>2020NYIST个人积分赛第九场F题</h2><h2 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h2><p><a href="https://codeforces.com/problemset/problem/1144/F" target="_blank" rel="noopener external nofollow noreferrer">https://codeforces.com/problemset/problem/1144/F</a></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个无向图，让你把所有边标记方向，并使其没有距离$&gt;=2$的边，问你是否存在并输出方案。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><script type="math/tex; mode=display">\begin{equation}\label{eq1}
e=mc^2
\end{equation}</script><p>著名的质能方程 $\eqref{eq1}$ 由爱因斯坦提出 …<br>距离大于等于2，可不就是分成两个点集， $A$和 $B$ ，使得只存在从 $A$ 到 $B$B的边，不存在回来的边，显然就是二分图（Orz），还是图论做少了，就很$sb$的二分图染色。</p>
<blockquote>
<p>枚举点，染色黑白点之间随便定一个方向，可以黑到白也可以白到黑。<br>$dfs$即可。</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nuoyanli</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(false), cin.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kB kush_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FI first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SE second</span></span><br><span class="line"><span class="comment">//#define in</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RI register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> m_k(a, b) make_pair(a, b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB(a) push_back(a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(a) cout &lt;&lt; <span class="meta-string">"---"</span> &lt;&lt; a &lt;&lt; <span class="meta-string">"---"</span> &lt;&lt; endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug_(a, b) cout &lt;&lt; a &lt;&lt; <span class="meta-string">"---"</span> &lt;&lt; b &lt;&lt; endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bl(x) setiosflags(ios::fixed) &lt;&lt; setprecision(x)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> LL inf = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> f = <span class="number">0.32349</span>;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"><span class="keyword">int</span> n, m, col[N];</span><br><span class="line"><span class="keyword">bool</span> vs = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	col[u] = c;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> v:G[u]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (col[v] == <span class="number">-1</span>) &#123;<span class="comment">//没有染过色</span></span><br><span class="line">			dfs(v, c ^ <span class="number">1</span>);<span class="comment">//染上与现在不同的颜色</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (col[v] == c) &#123; <span class="comment">//有一个点已经染色且与当前点颜色相同</span></span><br><span class="line">			vs =<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span> &lt;pair &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;Edges;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	IOS;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> u, v;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		--u, --v;<span class="comment">//从0开始编号</span></span><br><span class="line">		G[u].PB(v);</span><br><span class="line">		G[v].PB(u);</span><br><span class="line">		Edges.PB(m_k(u, v));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(col, <span class="number">-1</span>, <span class="keyword">sizeof</span>(col));<span class="comment">//-1表示没有染过色</span></span><br><span class="line">	dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(vs) &#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> i:Edges) &#123;</span><br><span class="line">			<span class="keyword">if</span> (col[i.FI] == <span class="number">0</span>)<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
</search>
